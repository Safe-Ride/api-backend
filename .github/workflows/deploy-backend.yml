name: deploy-backend

#on:
#  pull_request_review:
#    types: [submitted]
#
#jobs:
#  deploy:
#    if: github.event.review.state == 'approved' && github.event.pull_request.merged == true

on:
  pull_request:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    needs: build # Dependência configurada aqui

    steps:
      - name: Recuperar JAR
        uses: actions/download-artifact@v3
        with:
          name: aplicacao
          path: ./ # diretório da VM de execução do workflow onde os arquivos recuperados ficarão

      - name: Recuperar scripts
        uses: actions/download-artifact@v4
        with:
          name: scripts
          path: ./

      - name: Criar arquivo .pem a partir da variável DEPLOY_KEY e fazer o chmod 400 nele
        id: geracao-arquivo-pem # o id é opcional, mas é bom para fins de log
        run: |
          echo "${{ secrets.DEPLOY_KEY }}" >> $HOME/${{ secrets.NOME_ARQUIVO_PEM }}
          chmod 400 $HOME/${{ secrets.NOME_ARQUIVO_PEM }}
        # aqui geramos um arquivo .pem a partir de seu conteúdo (que é apenas um arquivo texto)

      - name: Enviar o JAR p/ a EC2
        uses: appleboy/scp-action@master # esta action abstrai o uso do comando scp, permitindo o envio de arquivos via ssh
        with:
          host: ${{ secrets.DEPLOY_HOST }} # ip da ec2 pública
          username: ubuntu
          key: ${{ secrets.DEPLOY_KEY }} # conteúdo pem que permite acesso à ec2 pública
          source: "./*.jar" # enviando todos os .jar (estão lá graças ao step 'Recuperar jars')
          target: "/home/ubuntu/deploy-api/" # diretório de destino na ec2 pública

      - name: Enviar os Scripts p/ a EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ubuntu
          key: ${{ secrets.DEPLOY_KEY }}
          source: "./*.sh" # enviando todos os .jar (estão lá graças ao step 'Recuperar scripts')
          target: "/home/ubuntu/deploy-api/" # diretório de destino na ec2 pública

      - name: Conectar via SSH à EC2 privada para implantar e reiniciar a API
        run: |
          ssh -o StrictHostKeyChecking=no -i $HOME/${{ secrets.NOME_ARQUIVO_PEM }} ubuntu@${{ secrets.DEPLOY_HOST }} '
            scp -i ${{ secrets.NOME_ARQUIVO_PEM }} deploy-api/${{ secrets.NOME_ARQUIVO_JAR }} ubuntu@${{ secrets.IP_PRIVADO_EC2 }}:/home/ubuntu/deploy-api
            scp -i ${{ secrets.NOME_ARQUIVO_PEM }} deploy-api/*.sh ubuntu@${{ secrets.IP_PRIVADO_EC2 }}:/home/ubuntu/deploy-api
            ssh -i ${{ secrets.NOME_ARQUIVO_PEM }} ubuntu@${{ secrets.IP_PRIVADO_EC2 }} "sh /home/ubuntu/deploy-api/api-restart.sh"          
          '
        # aqui nós nos conectamos via SSH na ec2 pública e, nela, executamos 3 comandos:
        # 1. copiamos o arquivo .jar para a ec2 privada
        # 2. copiamos os arquivos .sh para a ec2 privada
        # 3. pedimos a execução de um dos arquivos .sh recém copiados para a ec2 privad
        # os passos #1 a #3 poderiam estar num script sh. Fiz assim para mostrar outra forma de executar comandos via github actions
